\chapter{Related Work}

\section{Introduction}

Since the release of USB in 1996 \cite{WaybackMachine2018} black (malicious) and white (benevolent) hats (hackers) have equally pursued the development of increasingly sophisticated methods to attack and defend, respectively. This chapter will expand on their works chronologically and thereby illustrate the lengths both sides have gone to fight for the upper hand in this co-evolution.\\
It has to be kept in mind that even the most sophisticated defence techniques have weaknesses, the biggest of which is the user itself. Social Engineering attacks are infamous, and can be infamously effective \cite{krombholzAdvancedSocialEngineering2015}. Unless it is physically impossible to attack a USB device to a host, there will always be a way to convince an unsuspecting target to plug it in for you.\\ 
Similarly, HID attacks can fail for the most mundane reasons. This form of attack is not very flexible, and an unexpected pop-up, a keystroke by the user at the wrong moment, or one small timing miscalculation could fatally influence the attack. This problem will be expanded upon in Section \ref{Attack Implementation}.\\
Nevertheless, the risk of a hack makes it worth for both sides to put in the effort, as documented in the following subsections.

\section{Attack}

Nissim et al. (2017) \cite{nissimUSBbasedAttacks2017} ID attacks. They classify 29 different USB-based attacks into 3 main categories and 2 subcategories. The distinction is based on hardware, categorized into Electrical, Programmable Microcontrollers, and USB Peripherals. USB Peripherals are further divided into maliciously reprogrammed and non-reprogrammed devices. These are examples of some attacks in those categories:

\begin{enumerate}
  \item Electrical: Most notably the USB Killer attacks; a device that can discharge high voltage power surges to damage the device it is plugged into. \cite{USBKillDevices}
  \item Programmable Microcontrollers: Rubber Ducky, USBdriveby, Turnipschool, URFUKED.
  \item Peripherals:
  \begin{itemize}
      \item Re Programmed Peripherals: smartphone-based HID attacks, iSeeYou attack
      \item Non-Reprogrammed Peripherals: USBee attack, Stuxnet
  \end{itemize}
\end{enumerate}
	

The attacks in this thesis fall into the category of programmable microcontrollers. The following section will give an overview of the evolution of these programmable microcontrollers.

\subsection{Attack History} \label{HistoryOfAttacks}

One of the first documented attacks conducted via USB was done using a tool called Slurp \cite{SharpIdeasDownloads2006} which was available as early as 2006 and could attack an iPod via a charging cable to search through its files looking for certain file extensions. Although it was suggested by the authors that the implementation could be modified to extract the files, it only displays the number of matching files found, as its purpose is to raise awareness rather than be used for malicious purposes.

In the same year \cite{al-zarouniRealityRisksConsented2006} published a paper demonstrating another early version of the USB attack utilizing a functionality called U3, which was developed to allow users to carry portable applications on USB sticks. The USB stick in question would pose as two pieces of hardware; a CD-ROM device and a USB storage device. The attack can then be mounted by hacking the auto-run feature of CD-ROM. This meant code could be executed automatically on the target machine only via the USB stick. 

In 2009 \cite{clarkHardwareTrojanHorse2009} described a data exfiltration process via USB that they called a Hardware Trojan Horse. This Trojan was built into a keyboard for disguise and used its ``unintended" USB channels; the keyboard LED and audio channel function as a communication tool from the computer to the keyboard and could therefore be repurposed to exfiltrate data. This network endpoint data could then be searched for sensitive information and the findings be sent to the attacker. With their paper the researchers wanted to raise awareness for this kind of attack, they write ``Physical access can now be potentially sufficient to compromise a network endpoint, without attempting access through the network." \cite[p.~7]{clarkHardwareTrojanHorse2009}.
Expanding on their work with data exfiltration, Clark et al.\cite{clarkRisksAssociatedUSB2011} released a paper in 2011 demonstrating how peripheral hardware Trojans can be used to execute code on the USB host \cite{clarkRisksAssociatedUSB2011}. 

2010, Wang and Stavrou \cite{wangExploitingSmartphoneUSB2010} were the first to describe attacks propagated via USB while launched from a smartphone or computer. They demonstrated propagation from phone to phone, phone to computer, and computer to phone.

At Defcon 2010 Adrian Crenshaw presented a USB dongle he called Programmable HID USB Keystroke Dongle (PHUKED) and later published the instructions on how to build it on his website \cite{ProgrammableHIDUSB}. The penetration testing device was built using a Teensy microcontroller. It could be programmed to spoof a keyboard and emulate keystrokes on an unlocked computer. 

The company Hak5 launched the first version of the USB Rubber Ducky in 2010 \cite{USBRubberDucky}. It is a commercially available, closed-source keystroke injection tool disguised as a normal USB flash drive. It runs on its own scripting language called DuckyScript, which has 3 versions already, the newest one even supporting control flow constructs, repetitions, and functions. The Rubber Ducky has a USB A and a USB C end \cite{USBRubberDucky2023}. This commercialization made the USB attack widely accessible. BadUSB no longer tediously have to be made at home instead, they can be bought for 80 USD\cite{USBRubberDucky2023} on the internet. 

Lau et al., 2013 \cite{lauMactansInjectingMalware2013} showed that USB attacks on iOS6 are possible. Within one minute of being plugged into the charger cable, the phone was compromised. The approach leverages USB to bypass Apple's security mechanism protecting their devices from arbitrary software installations. On top of the malware installation, the software can also be hidden from the user in the same way as Apple hides its own built-in applications. The hardware the authors designed for this study is called Mactans and uses a BeagleBoard.
With iOS 7 Apple already implemented the protective measures proposed by this paper and thereby patched this particular attack vector. 

While all of these developments were impressive and pushed the field forward, it is not known when exactly government actors joined the field of research around USB attacks. However, in 2013 a story in the German newspaper Der Spiegel revealed that the US government had been conducting significant research in this area \cite{appelbaumCatalogRevealsNSA2013}. Developed by the NSA, one of the first USB-based man-in-the-middle attack tools, Cottonmouth I could be built into keyboards or accessory cables. It is part of a large collection of tools developed for the NSA called the ANT-Catalogue \cite{InteractiveGraphicNSA}. In the device catalogue, Cottonmouth is advertised as a "hardware implant which will provide a wireless bridge into a target network as well as the ability to load exploit software onto target PCs". This very early attack tool was only available in batches of 50 for a total price of 1'015'000\$ (20'000\$ / piece).

The NSA playset project is an open-source project that tries to replicate the technologies revealed in the ANT-Catalogue \cite{NSAPlaysetTurnipschoolHtml}. Michael Ossman replicated Cottonmouth I as a part of this project with a device called Turnipschool, making the technology available to the public. A full instruction on how to build it can be found on the GitHub page of the NSA-Playset Project \cite{NSAPlaysetTurnipschoolHtml}.

USBdriveby was developed by Samy Kamkar in 2014 \cite{SamyKamkarUSBdriveby}. It is a device that can simulate keyboard and mouse input in order to install a backdoor and override DNS settings to control the flow of network traffic within seconds of being plugged in on a Windows machine. The device is built on a Teensy microcontroller and can be worn as a necklace.

In August of 2014 Karsten Nohl, Sasch Krissler, and Jakob Lell presented their research on USB attacks at the BlackHat Convention \cite{Srlabsbadusbblackhatv1Pdf2014}. They had reverse-engineered and patched USB firmware in such a way that they created a useable, programmable, well-disguised USB attack tool from a normal USB flash drive. They called it Bad USB. It could emulate Keyboard input and even spoof an Ethernet connection, allowing a connected device to intercept all internet traffic from the attacked computer. Furthermore, the device can be used to mount a boot-sector virus, prompting a computer to boot an OS from the stick, or if necessary, emulate the keystrokes to initiate the boot from the USB stick. This presentation reached a big audience and caused a stir, inspiring many subsequent papers.

Han et al.\cite{hanIRONHIDCreateYour2016} developed a penetration testing framework called IRON-HID in 2016. It attaches to the existing USB devices turning them into Bad USBs. The hardware attachment can be built either with Arduino or Teensy. On top of that they constructed a framework to use the hardware for various penetration testing scenarios like brute force keyboard injections to guess PIN codes of smartphones or to test whether CD-ROM programs are automatically executed. Also part of the framework are a test agent program, and a commander program, giving the penetration tester ways to reliably execute and monitor their tests.   

Video Jacking is an attack demonstrated by Brain Kebs \cite{RoadWarriorsBeware2016} at Defcon 2016. He built a demonstration to raise awareness for USB-based attacks by putting up a booth that would 'charge' your phone. Once the phone was connected, however, the video feed from the camera was shown on a monitor without any additional action by the user. 

Inspired by PHUKED, \cite{elkinsHackingHardwareIntroducing} released an improved version of the USB Dongle at Defcon 2018, called URFUKED based on Arduino that can additionally mount an HID attack by triggering it remotely.  

Another proof of concept was published by \cite{bojovicRisingThreatHardware2019} in 2019. In their paper, they documented how they implemented a keystroke logger and BadUSB in the keyboard of one of their colleagues using an Arduino microcontroller. They recorded the target's keystrokes on a built-in SD card that they then retrieved. The data was analyzed for sensitive data such as login information. In the next step they used their findings to contrive a custom script to exploit the Virtual Network Computing (VNC) service the target was using to gain remote control over the target machine. 

\label{malboard}2019 saw the development of a novel attack called Malboard \cite{farhiMalboardNovelUser2019}; Previously, detection of a keyboard attack was easy by identifying the keystroke dynamics as artificial (as discussed in section \ref{HistoryOfdefence}). Malboard instead generates keystrokes that pass as the attacked user's and thereby bypass the simple detection mechanism. In order to achieve this, the user's keystrokes are observed, analyzed, and emulated. To this end, a normal keyboard is modified with malicious components (a Teensy among others).  Two types of attacks can be executed with Malboard: 
\begin{enumerate}
    \item A statistical profile of the user's typing habits is synthesized on a remote C2 server. The remote server then sends the malicious payload via Wifi or a cellular connection. This is called Remote Server Injection (RSI). 
    \item Alternatively, Malboard can be used with Physical Access Injection (PAI) where the profile is made locally using the malicious microcontroller built into the modified keyboard. Once the attacker has gained physical access to the Malboard they can activate it with a specific key combination which will trigger the mechanism that relays the typed keystrokes to the host in a pattern consistent with the actual user's profile.
 \end{enumerate}
 Malboard was able to evade existing detection mechanisms in 83\% - 100\% of cases. It was able to fool DuckHunt every time while evading detection by Typing DNA and KeyTrac, two private keystroke authentication programs, in 83-93\% of cases. \\
 The researchers also proposed ways to defend against their attack, which will be discussed further in the detection section \ref{HistoryOfdefence}. \\
 This attack technique is a game changer because it can evade the first level of defences that focus on typing patterns and speed, which is the most intuitive way of blocking an HID injection attack. While that means that it might trick many systems that are put in place by a target, it also eliminates one of HID attack's biggest strengths; speed. Typing at a normal speed gives the user time to notice and interrupt the attack.  


Efendy et al. 2019 \cite{efendyExploringPossibilityUSB2019} showed that a fork bomb attack on Windows 8 can be carried out via USB. Fork Bomb is a Denial of Service (DoS) attack that creates new processes repeatedly thereby depleting system resources. The computer will run out of memory, causing errors. The user will no longer be able to give any input to the computer. Ultimately it will exhaust the resources of the OS, overtaxing the kernel and causing a crash.  

The O.MG cable is a handmade cable that poses as a normal USB cable with data transfer and charging capabilities \cite{hak5MGCable}. However, inside it, there is an implant that can mount sophisticated HID spoofing attacks. It was first released in 2019 with prototypes available at Defcon \cite{MGCable2019a} and is now commercially available on the Hak5 Website. It supports keystroke injection via DuckyScript, mouse injection, has 8-200 payload slots (depending on the version), a deployment speed of 120 - 890 keys/sec, a self-destruct feature, supports geo fencing, 192 different keyboard layouts, and wifi triggers. It is available in USB A or C, mini USB, and lightning ends. To use them they have to be flashed with the latest firmware with the programmer. \\
This attack vector is especially vicious because of the inconspicuousness of USB cables.  

In 2020 Dr. Kumar described a type of attack possible via USB called 'Juice Jacking' \cite{kumarJuiceJackingUSB2020}. It is a type of attack that specifically involves a malicious charging port (possibly in public) that initiates an attack when a device is connected, either installing malware or copying sensitive data from the device. He explains that this is possible because the data transfer mode on phones is enabled by default. 

In the same year, Muslim et al. \cite{muslimImplementationAnalysisUSB2020}, implemented a demonstration of how a USB attack can be leveraged to steal passwords stored in the browser of a Windows 10 PC using the Arduino Pro Micro Leonardo. They proved that it is possible to use keyboard injection to download scripts from GitHub to extract stored passwords from Chrome and Firefox and then send them to the email address of the attacker. 

Lawal et al. \cite{lawalFacilitatingCyberenabledFraud2022} 2022 were the first ones to publish a paper in which they used an O.MG cable to execute USB attacks. In their work, they showed that it is possible to carry out an attack through which a document is edited in such a way that it is impossible to tell whether the modifications were made by the cable or the user of the machine. The device seems to be "capable of perfectly modifying records and files without the forensic tools being able to differentiate between files modified by the user and files modified by the O.MG Cable". Although it is possible to find hints of the presence of an O.MG cable, it cannot be determined which actions were carried out by the cable as opposed to the user. The authors stress, that this can be misused to place incriminating information or otherwise alter the state of information on a PC while framing the user of the machine. 


The history of attacks is summarized in Table \ref{attack_table}

\Rotatebox{90}{
\begin{tabular}{|c c c c c c|} 
 \hline
 Name & Author / Inventor & Year & Characteristics & Hardware & Software \\ [0.5ex] 
 \hline \hline
 pod slurping & Sharp Tools \cite{SharpIdeasDownloads2006} & 2006 & iOS slurping via Lightning Cable &  &  $\times$ \\
 \hline
 -  &  Al-Zarouni \cite{al-zarouniRealityRisksConsented2006} & 2006 & stick / CD-ROM & & $\times$\\
 \hline
 Hardware Trojan & Clark \cite{clarkHardwareTrojanHorse2009} & 2009 and 2011 & built-in keyboard and audio & $\times$ & $\times$ \\
 \hline
 - & Wand and Stavrou \cite{wangExploitingSmartphoneUSB2010} & 2010 & attack propagated by USB & & $\times$\\
 \hline
 PHUKED & IronGeek  (Adrian Crenshaw) \cite{ProgrammableHIDUSB} & 2010 & stick / 'dongle' & $\times$ & $\times$  \\
 \hline
 USB Rubber Ducky & Hak5 \cite{USBRubberDucky} & 2010 & Stick & $\times$ & $\times$ \\
 \hline
 Mactans & Lau et al. \cite{lauMactansInjectingMalware2013} & 2013 & IOS6 attack & $\times$ & $\times$ \\
 \hline
 Cottonmouth & NSA \cite{appelbaumCatalogRevealsNSA2013} & 2013 & cable / built-in & $\times$ & $\times$ \\ 
 \hline
 Turnipschool & NSA-playset \cite{NSAPlaysetTurnipschoolHtml} & 2015 & cable / built-in & $\times$ & $\times$ \\
 \hline
 USB Driveby & Samy Kamkar \cite{SamyKamkarUSBdriveby} & 2014 & USB 'stick' & $\times$ & $\times$ \\
 \hline
 Bad USB & Nohl et al.\cite{Srlabsbadusbblackhatv1Pdf2014} & 2014 & programmable HID spoofing USB Stick & $\times$ & $\times$\\
 \hline
 IRON-HID & Han et al \cite{hanIRONHIDCreateYour2016} & 2016 & DIY Framework & $\times$ & $\times$ \\
 \hline
 - & Brian Kebs\cite{RoadWarriorsBeware2016} & 2016 & Video Jacking & & $\times$\\
 \hline
 URFUKED & Monta Elkins \cite{elkinsHackingHardwareIntroducing} & 2018 & USB stick & $\times$ & $\times$\\
 \hline
 -  & Bojovic \cite{bojovicRisingThreatHardware2019} & 2019 & built-into keyboard & $\times$ & $\times$ \\
 \hline
 Malboard & Fahri et al. \cite{farhiMalboardNovelUser2019} & 2019 & keystroke profiling & $\times$ & $\times$\\
 \hline
  - & Efendy\cite{efendyExploringPossibilityUSB2019} & 2019 & Fork Bomb Attack & & $\times$ \\
 \hline
 O.MG Cable & MG and Hak5  \cite{hak5MGCable} \cite{MGCable2019a} & 2019 & USB Cable & $\times$ & $\times$ \\
 \hline
- & Kumar \cite{kumarJuiceJackingUSB2020} & 2020 & Juice Jacking & $\times$ & $\times$ \\
\hline
- & Muslim \cite{muslimImplementationAnalysisUSB2020} & 2020 & stealing passwords & & $\times$ \\
\hline
-  & lawal \cite{lawalFacilitatingCyberenabledFraud2022} & 2022 & O.MG cable attack & & $\times$ \\
 \hline 
\end{tabular}
\label{attack_table}
}

\subsection{Conclusion of Attack History}

Attacks using USB have developed remarkably; it started with exploiting autorun features of CDs \cite{al-zarouniRealityRisksConsented2006}  and accessing iPods  \cite{SharpIdeasDownloads2006}, went on to be carried by the open source community \cite{NSAPlaysetTurnipschoolHtml} in the 2010s that built BadUSB at home \cite{SamyKamkarUSBdriveby} and drew attention to HID spoofing attacks at conventions and in talks \cite{Srlabsbadusbblackhatv1Pdf2014} and eventually culminated in the development of intricate systems like Malboard \cite{farhiMalboardNovelUser2019}, that featured microcontrollers, machine learning, and keystroke fingerprinting and advanced commercial technologies like the O.MG cable \cite{hak5MGCable}. These efforts did not go unnoticed; the next section describes the responses to these developments prompted by those working to protect against such threats.



\section{defence} \label{HistoryOfdefence}

The previous section outlined the evolution of attack tools, this sub-chapter will contrast that with the evolution of counter measurements and techniques. 


\subsection{Defence History} \label{defence_history}


Keystroke dynamics describe a biometric that is unique to each person. It is made up of the way they type on a keyboard, similar to how each person has unique handwriting. Leveraging this characteristic,  in 2012 \cite{barbhuiyaAnomalyBasedApproach2012} developed an approach to detect anomalies in HID input in order to thwart USB HID injection attacks. It relies on studying a user's behaviour such as holding time, typing speed, etc. This approach is very versatile and can be used independently of hardware, platform, and operating system. 

One of the first published defence systems was USBGuard \cite{HomeUSBGuard}, released in 2014. It is a Linux-based Daemon that implements black- and whitelisting of USB devices based on user-defined rules. To this end, it supports its own specific rule syntax \cite{RuleLanguageUSBGuard}. The devices are identified through their name, serial number, port, and interface type. These values are then stored in a hash. The custom rules furthermore support time-based attributes and random values. This system is only available on Linux and has been accused of being unsafe by \cite{farhiMalboardNovelUser2019} since the device identification metrics can be spoofed with a Teensy. 

GoodUSB \cite{tianDefendingMaliciousUSB2015} is a program that relies on user input to defend against malicious USB. It features a graphical interface that prompts users to select the device class they expect and then compares that expectation with the information given by the newly connected device. If the user's expectation does not match the device, access to the computer is denied. Additionally, the program doesn't support reenumeration. In theory, a BadUSB will register as a USB storage stick and GoodUSB will only allow actions compliant with the behavior of that device type. Any HID spoofing will be blocked. 
\cite{nissimUSBbasedAttacks2017} criticizes that GoodUSB assumes all devices are uncompromised when first contact is made. It is therefore not guaranteed to work with already infected devices (for example Teensy built into a keyboard). 
\cite{mohammadmoradiMakingWhitelistingBaseddefence2018} criticizes this approach as missing a reliable solution for uniquely identifying registered USB devices. In cases of the devices using a base class code, spoofing would still be possible, the same is true for devices using vendor-specific interfaces (mostly cellphones). 

The Idea of Cinch \cite{angelDefendingMaliciousPeripherals2016}, a defence mechanism developed in 2016, is to treat peripheral devices, like USB devices on a kernel level as though they were untrustworthy network endpoints. To this end it would build an extra layer between the device and the computer, channelling traffic through a ``choke point'' where the actual defence takes place. These defences called ``policies'' in the context of Cinch, include static rules (pattern matching) or checking specifications of expected devices against actual traffic. 
These modifications do not require changes to the computer hardware, nor do they impose an unreasonable overhead on the system.
\cite{farhiMalboardNovelUser2019} describes Cinch as ``Middleware that behaves as a separation layer between the host computer and the USB device." However, they critique: "USB attacks can be mutated and randomized to avoid detection by those kinds of mechanisms." \cite[p.~7]{farhiMalboardNovelUser2019}

SandUSB (2016) consists of a physical middleware and user interface to control and monitor USB devices connected to a host \cite{loeSandUSBInstallationfreeSandbox2016}. Furthermore, it features automatic defensive measures, five of which come out of the box: blacklisting, keyboard dynamic analysis, file and settings modification detection, input pattern matching, and USB packet analysis. Further semi-automatic measures can be configured through the UI. 
During enumeration, USB device information such as PID, VID, and device class are presented to the user. A user can spot a spoofing device by comparing these values with their expectations and blacklist the device immediately if they wish.
Additionally, the keyboard dynamics analysis detects malicious input by unusual speed and typing patterns. Should a USB device try to access sensitive settings and files, SandUSB can block the access to prevent attacks. Lastly, the authors claim to detect malicious payloads, although they do not specify how. 

USG \cite{robertfiskRobertfiskUSG2016} is a hardware USB firewall designed in New Zealand. It is designed to prevent supply-chain attacks and has open-source firmware that can even be custom-written. It limits the speed of packets to 12Mbps, protecting against high-speed injection attacks. Furthermore, it supports whitelisting ``known-safe commands" and thereby simplifies the USB interface. Additionally, it prevents run-time class changes (re-enumeration) of USB devices. Finally, it implements an ``HID bot detection" that detects insufficiently random inputs and blocks HID input from that USB for 4 seconds while flashing a warning light. 

Risk management is of special concern in areas with high stakes, such as Industrial Control Systems (ICS). To mitigate the risks of a USB attack on ICS \cite{yangTMSUITrustManagement2016} has developed a trust management scheme called TMSUI, which was published in 2016. It manages access rights for USB devices; administrators can grant access to individual devices (whitelisting) and set rules for what they are or are not allowed to do. USB devices are identified through their Vendor ID (VID) and serial number (SN). The only hardware modification that is necessary for this scheme is a Trusted Platform Module (TPM) chip which is often already present in modern devices for singing the admin keys during the whitelisting process. \\
Both VID and SSN can be modified with an O.MG device which makes a spoofing attack possible.

Building on packet-level control USBFilter \cite{tianMakingUSBGreat2016} is a program for USB designed to prevent unauthorized devices from successfully connecting to the host. In addition, USBFilter can also restrict access to individual applications (e.g. only Video Conference apps can access a webcam). The firewall checks a user-defined rule database and executes the action defined for the first match for the packet. Interceptions are done in the kernel thereby controlling access to both physical and virtual devices. USB packets are tracked to their original USB application by passing the PID along down the software stack, however, this is only possible for non-HID devices.
\cite{nissimUSBbasedAttacks2017} criticizes this solution for being deterministic and only detecting known attacks. 

2017 saw the release of Curtain \cite{fuCurtainKeepYour2017}. Its authors created a process to detect USB attacks which is made up of three methods:
\begin{itemize}
    \item User's choice; The program will prompt the user when a new USB device is connected to provide the expected device type. If that does not match the specification given by the device itself, a warning is issued. If the user is suspicious they can use Curtain to disallow access and ban the USB device.
    \item Isolation Forest algorithm; The algorithm is used to detect abnormalities in file access by analyzing the I/O request packet (IRP) flow from the USB device. 
    \item Static rules: depending on the type of USB device a newly connected entity claims to be, certain operations can be expected. Any device that does not conform to these rules will be brought to the user's attention. 
\end{itemize}
The authors argue that a combination of these methods will make a system 'well-suited for protecting any USB workload'.  The disadvantage is that the functionality of Curtain is dependent on the user, which leaves room for social engineering workarounds.  

FirmUSB is a framework developed in 2017 that analyses firmware images of USB devices as a tool to detect malicious USB devices \cite{hernandezFirmUSBVettingUSB2017}. It constructs a model of a connected device using the information generated in the enumeration process. This model is compared to the actual behaviour of the device. For example, a HID device would not be expected to have the large storage capacity of a BadUSB looking to exfiltrate data. Discrepancies such as these indicate malicious intent. 

USBWall, also released in 2017 creates a sandbox for USB device enumeration \cite{kangUSBWallNovelSecurity2017}. It intercepts the connection on a middleware built on a BeagleBoneBlack, where the connection is analyzed and rejected if it is malicious. It is also built on USBproxy by Dominic Spill \cite{dominicspillShmooCon2014Open2014}, which relays USB traffic from the device to the host. In this manner, USBWall sandboxes the connection until the user requests functionality from the USB device through the USBWall UI where they can check whether the characteristics of the USB as presented to the computer match their expectations of the device they plugged in. They can then choose whether to establish the connection to the USB device.  

A framework developed by \cite{erdinOSIndependentHardwareAssisted2018} in 2018 implements a USB data sniffer, that looks at the USB packets upon USB enumeration. Certain rules can be set by an administrator to block or allow certain types of devices, such rules can be manufacturer or product ID, a threshold for packet speed, or interface descriptors like mice, printers, keyboards, mass storage devices, etc. If a USB packet matches one of the rules, the communication is reset. This solution is OS and hardware-independent. 

Mohammadmoradi \cite{mohammadmoradiMakingWhitelistingBaseddefence2018} pursued the idea of fingerprinting and whitelisting USB devices in 2018. In order to be able to identify every USB device individually and reliably, 24 features are evaluated, including DeviceType, VendorID, ProductID, USBClass, and DriverFileName. With this approach, a unique fingerprint is created. They found that they were able to identify each USB device they tested with an accuracy of 98.5\%  and could also detect changes in usage and block services that were requested upon reenumeration. This makes spoofing much harder. To successfully circumvent this measure, the firmware of a whitelisted device would have to be patched. All devices that are not on the whitelist are assumed to be suspicious. \\
This method does not protect against keystroke logging. 

\cite{neunerUSBlockBlockingUSBBased2018} developed a mechanism that depends on packet speed analysis for detecting rapid keystroke injection attacks. They define a Rapid (keypress) event sequence (RES) as a sequence of s consecutive keypresses with less than ``t'' seconds between them. An alarm is raised if keyboard input above a certain (implementation-specific) threshold for RES is detected. The authors argue, that more sophisticated attacks could mimic human typing, however, this would eliminate the biggest appeal of an HID injection attack; high speed. If an authentic typing pattern is mimicked, the user has time to notice and stop the attack.

In 2019 \cite{denneyUSBWatchDynamicHardwareAssisted2019} developed a system called USB-Watch. It includes a hardware device that is placed between the USB device and the host. It intercepts the USB communication, collects the data, and feeds it into machine learning algorithms to classify them. It promises to distinguish between genuine and faked human keystroke characteristics based on four metrics; time between two keystrokes (Key Transition Time, KTT), how long a key is held (Duration Held, DH), and their respective normalized values. In this way, the system claims to be able to detect keystroke injection that mimics human behaviour by adding 100ms delays or random delays between 100ms and 150ms to the input with an ROC of 0.89. This implementation is OS-independent.


The authors of Malboard \cite{farhiMalboardNovelUser2019}, which is already introduced in Paragraph \ref{malboard}, also proposed countermeasures to their invention in the form of three detection modules based on side-channel resources. 
\begin{enumerate}
    \item Comparing the keyboard's power consumption with the expected one.
    \item Checking the delay between a keystroke signal to the host and the sound of the keystroke as recorded by the computer's microphone. A concealed Teensy causes additional processing time which extends the delay.
    \item By Typo Inspection: A program randomly injects typos while the user is typing. By tracking whether and with what timing the error is corrected, an injection attack can be detected.
\end{enumerate}
RSI attacks would fail at this exercise because they do not produce any sound and can't correct random typos while PAI attacks would reveal themselves by the delay caused by the Teensy.   
In contrast to existing detection algorithms, which Malboard was able to evade in 83\% - 100\% of cases, these side channel methods have a 100\%  detection rate for Malboard with no misses and no false positives.  


Another detection method using side channels was proposed by \cite{ibrahimRFDNAFingerprintingDetection2019} in 2019. They found that it is possible to distinguish between normal USB devices and Rubber Duckies by using the unintentional radiated emissions (URE) produced by the electronic components of the USB devices. 

USBSafe utilizes machine learning to detect suspicious USB communication \cite{kharrazUSBESAFEEndPointSolution2019}. They train different machine learning algorithms on 14 months of unsuspicious, normal USB traffic data generated by devices such as keyboards, mice, headsets, mass storage devices, and cameras. They were able to narrow the considered classification features down to three categories; content-based, timing-based, and type-based. They achieved their highest accuracy and precision rates, with a true positive (TP) rate of 95.7\% and 0.21\% false positive (FP) rate. BadUSB attacks were detected as novel observations, their communication data did not match the training data.
USBSafe has to be retrained every 16 days for 82 seconds to maintain a detection rate of 93\%.

In 2019 \cite{bojovicRisingThreatHardware2019} mentions the possibility of detecting an HID injection attack on a Smartphone by the (missing) vibrations of the keyboard. This possibility is further supported by \cite{zhuangKeyboardAcousticEmanations2009} who prove that it is possible to guess typing on a phone through motion sensors. So not only could the defence technique check for authentic keyboard vibrations but a further step could be to check the plausibility of the typing vibrations by the model made by \cite{zhuangKeyboardAcousticEmanations2009}. 

Also in 2019, the authors of \cite{IdentifyingHIDbasedAttacks2019} propose a system called HIDTracker that detects anomalies in HID logs to fight HID injection attacks. When a USB device is connected to a host, a HID event graph is constructed which is then tested against the actual interactions with the device. The process events and the objects within such an event graph are analyzed using the guilt-by-association method (GAD) and machine learning models such as random forests. In this way, USB spoofing should be detected as an anomaly to usual USB behaviour. The system has a 90\% precision rate and a 2.33\% false positive rate. 

MG, the creator of the O.MG Cable also published a device in 2020 called the Malicious Cable Detector \cite{hak5MaliciousCableDetector}, which can detect malicious cables through side-channel power analysis. A positive is indicated with a blinking light. Additionally, the device doubles as a USB condom, blocking data and allowing only the charging functionality of the cables. 

NetHunter \cite{IntelligentSystemPreventing} is a system published in 2021 that utilizes a deep learning artificial neural network (NN) to analyze multiple processes connected to USB device enumeration and deployment. It considers basic device identification parameters such as serial number, VID, and PID. Additionally, utilizes HID pattern identification by learning about existing RubberDucky attacks. Furthermore, it tries to predict behavioural patterns and compares its predictions to the actual input. Lastly, several fuzzy parameters are collected such as the program processing call rate parameter. These data points are then used to detect anomalies by the NN.


The Ducky-Detector \cite{USBRubberDucky2021} published in 2021 aims to identify USB rubber duckies by using heuristic checks. It springs into action when it detects two or more keyboards. If the user wishes to, it will disconnect the new keyboard. Otherwise, Ducky Detector will continue the enumeration of the device and check the provided keyboard state and type. If they differ from any observed metrics (i.e. a mismatch between the actual number of function keys and the expected number-based enumeration information) an alert is raised. Finally, it observes the input from the keyboards and issues an alert if their approximate keypress speed is above a certain threshold per minute. The study claims no false positives and an accuracy of 100\%. 

The authors of \cite{thomasDuckHuntMemory2021} chose a different approach for badUSB detection. They used digital forensic tools to analyze memory artefacts generated by USB Rubber Duckies and Bash Bunny. They built a system based on two open-source volatility plugins (usbhunt and dhcphunt) that extract the artefacts generated by plugging either of these devices into a Windows 10 machine. Some indicators of compromise (IOC) remain in memory for at least 24 hours. In addition to that, it was found that the payload scripts executed on the target machine were recoverable from memory as well. 


\Rotatebox{90}{%
\begin{tabular}{|c c c c c c|} 
 \hline
 Name & Author / Inventor &  Year & Characteristics & Hardware & Software \\ [0.5ex] 
 \hline\hline
 - & Zhuang \cite{zhuangKeyboardAcousticEmanations2009} & 2009 & Keyboard Vibrations & & $\times$ \\
 \hline
 USBGuard & USBGuard Project \cite{HomeUSBGuard} & 2014 & Black- and Whitelisting & & $\times$ \\
 \hline
 GoodUSB & Tian \cite{tianDefendingMaliciousUSB2015} & 2015 & register with user input &  & $\times$\\
 \hline
 Cinch & Angel \cite{angelDefendingMaliciousPeripherals2016} & 2016 & kernel level Middleware & & $\times$ \\
 \hline
 USBFilter & Tian \cite{tianMakingUSBGreat2016} & 2016 & Packet Level Filtering & & $\times$ \\
 \hline
 TMSUI & Yang \cite{yangTMSUITrustManagement2016} & 2016 & Whitelisting Tool & & $\times$ \\
 \hline
 USG & Robertfisk \cite{robertfiskRobertfiskUSG2016}  & 2016 & Hardware Firewall & $\times$ & $\times$\\
 \hline
 SandUSB \cite{loeSandUSBInstallationfreeSandbox2016} & Loe & 2016 & Hardware Sandbox & $\times$ & $\times$\\
 \hline
 USBWAll & Kang \cite{kangUSBWallNovelSecurity2017} & 2017 & USB Sandbox & $\times$ & $\times$ \\
 \hline
 Curtain &  Fu \cite{fuCurtainKeepYour2017} & 2017 & analyze IRP, User Participation & & $\times$\\
 \hline
 FirmUSB & Hernandez \cite{hernandezFirmUSBVettingUSB2017} & 2017 & Firmware Images vs Expectations & & $\times$\\
 \hline
 - & Erdin \cite{erdinOSIndependentHardwareAssisted2018} & 2018 & USB Data Sniffer with Static Rules & $\times$ & $\times$ \\
 \hline
 -  & Mohammadmoradi \cite{mohammadmoradiMakingWhitelistingBaseddefence2018}  & 2018 & USB Whitelisting  & & $\times$\\
 \hline
 - & Neuner \cite{neunerUSBlockBlockingUSBBased2018} & 2018 & Speed Limit for Packets & & $\times$ \\
 \hline
 USB-Watch & Denny \cite{denneyUSBWatchDynamicHardwareAssisted2019} & 2019 & Hardware USB intercept and ML keystroke detection & $\times$ & $\times$ \\
 \hline
 - & Ibrahim \cite{ibrahimRFDNAFingerprintingDetection2019} & 2019 & URE Fingerprinting & $\times$ & $\times$\\
\hline
 HIDTracker & Huang \cite{IdentifyingHIDbasedAttacks2019} & 2019 & HID Event Tree and ML Anomaly Detection & & $\times$ \\
 \hline
 Malboard & Fahri et al. \cite{farhiMalboardNovelUser2019} & 2019 & 3 Side Channels & $\times$ & $\times$\\
 \hline
- & Barbhuiya \cite{barbhuiyaAnomalyBasedApproach2012} & 2012 & Keystroke Anomalies & & $\times$ \\
 \hline
 USBSafe & Kharraz \cite{kharrazUSBESAFEEndPointSolution2019} & 2019 & ML trained on USB traffic & & $\times$\\
 \hline
 Malicious Cable Detector & MG and Hak5 \cite{hak5MaliciousCableDetector} & 2020 & Hardware Side Channel Detection & $\times$ & $\times$ \\
 \hline
 NetHunter & Tyutyunnik \cite{IntelligentSystemPreventing} & 2021 & Neural Network Rubber Ducky detection & & $\times$\\
 \hline
 Ducky-Detector & Arora \cite{USBRubberDucky2021} & 2021 & Heuristic Checks & & $\times$\\
 \hline
 Duck Hunt & Thomas \cite{thomasDuckHuntMemory2021} & 2021 & Memory Forensics with Artifacts & & $\times$ \\
\hline
\end{tabular}
}%



\subsection{Conclusion defence History}

Counteracting the innovations on the attack side are a multitude of projects and approaches that leverage all kinds of tools and ideas to counter a HID spoofing attack. Many rely on detecting anomalies in input, using machine learning and statistical models to distinguish between real and human input, multiple use filtering and static rules to allow or disallow actions, some rely on user input, warning the user from suspicious devices or asking them to confirm their actions. White or blacklists are common, using various ways to fingerprint devices, others use side channels like radio emissions, sounds, vibrations, error injections etc. to find BadUSB. Finally, after an attack, memory forensics can be employed to find out the extent of an attack. These methods cover many bases and offer a multitude of solutions for all kinds of situations where a user might need protection against HID spoofing attacks.


\section{Conclusion Related Work}


This chapter introduced the history of HID spoofing and keyboard injection attacks and recounted their development as tools of government, open source enthusiasts and White Hats who raise awareness within their communities and beyond for the capabilities and dangers of these tools. It introduced the diverse and numerous ways in which these attacks can be prevented, thwarted, and investigated. \\
In the next chapter, this thesis will add to that history, developing new attack scripts and a defence system that incorporates an approach, not yet seen in any of these examples.


